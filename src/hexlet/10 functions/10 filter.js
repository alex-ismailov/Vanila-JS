/* Типичная задача может выглядеть так — выберем пользователей старше 10 лет: */
const users = [
  { name: 'Igor', age: 19 },
  { name: 'Danil', age: 1 },
  { name: 'Vovan', age: 4 },
  { name: 'Matvey', age: 16 },
];

const res = [];
for (const user of users) {
  if (user.age > 10) {
    res.push(user);
  }
}
console.log(res); // => [ { name: 'Igor', age: 19 }, { name: 'Matvey', age: 16 } ]


/* Общая схема кода при фильтрации практически один в один как и в отображении,
кроме пары ключевых моментов:
Фильтрация возвращает коллекцию либо того же размера (если ничего не было отфильтровано),
либо меньшего. Она может вернуть даже пустую коллекцию, если ни один из элементов не подошёл.
Фильтрация всегда возвращает исходные элементы. Она никогда не делает отображение.
Если на вход фильтрации поступил список пользователей, то список пользователей будет
и на выходе. */

// const res2 = users.filter((user) => user.age > 10);
const res2 = users.filter(({age}) => age > 10);
console.log(res2);
/* Callback-функция, передаваемая в filter, должна быть предикатом.
То есть её задача вернуть либо true, либо false для каждого элемента коллекции.
Значение, которое возвращается, никак не используется — оно всего лишь говорит о том,
включать ли текущий элемент в итоговый массив или нет.
Новички часто делают ошибку на этом этапе и начинают возвращать из фильтра то,
что они бы хотели увидеть в результирующем массиве (для этого надо применять map). */


/* Напишем свою собственную функцию, реализующую операцию фильтрации: */
const myFilter = (callback, collection) => {
  res = [];
  for (const item of collection) {
    if (callback(item)) {
      res.push(item);
    }
  }
  return res;
};
